{"version":3,"sources":["subnet-engine.js"],"names":["SubnetEngine","isValidIP","ip","split","octets","length","every","octet","num","parseInt","toString","isValidPrefix","prefix","Number","isInteger","ipToInt","int","intToIP","join","toBinary8","padStart","ipToBinary","map","prefixToMask","getNetworkAddress","ipInt","getBroadcastAddress","getFirstUsable","networkAddr","getLastUsable","broadcastAddr","getUsableHosts","Math","pow","getTotalAddresses","firstOctet","isPrivateIP","calculateSubnets","baseIP","basePrefix","newPrefix","arguments","undefined","Error","subnetNumber","networkAddress","broadcastAddress","subnetMask","usableHosts","baseNetworkAddr","baseNetworkInt","subnetSize","subnets","i","subnetNetworkInt","push","numSubnets","lastUsable","getCalculationSummary","effectivePrefix","baseNetwork","totalSubnets","hostsPerSubnet","totalAddresses","networkClass","isPrivate","getBinaryBreakdown","o","mask","maskOctets","networkOctets","decimal","fullBinary","breakdown","networkBits","hostBits","getNetworkClass"],"mappings":"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","file":"subnet-engine.min.js","sourcesContent":["/**\r\n * ============================================\r\n * Subnet Engine - Core Calculation Logic\r\n * ============================================\r\n * This module handles all subnet calculations including:\r\n * - IP address manipulation and validation\r\n * - Subnet mask generation\r\n * - Network and broadcast address calculation\r\n * - Usable host range determination\r\n * - Binary conversions\r\n * ============================================\r\n */\r\n\r\nconst SubnetEngine = (function() {\r\n    'use strict';\r\n\r\n    /**\r\n     * Validates an IPv4 address\r\n     * @param {string} ip - IP address to validate\r\n     * @returns {boolean} - True if valid\r\n     */\r\n    function isValidIP(ip) {\r\n        const octets = ip.split('.');\r\n        if (octets.length !== 4) return false;\r\n        \r\n        return octets.every(octet => {\r\n            const num = parseInt(octet, 10);\r\n            return num >= 0 && num <= 255 && octet === num.toString();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Validates a CIDR prefix\r\n     * @param {number} prefix - Prefix length to validate\r\n     * @returns {boolean} - True if valid\r\n     */\r\n    function isValidPrefix(prefix) {\r\n        return prefix >= 0 && prefix <= 32 && Number.isInteger(prefix);\r\n    }\r\n\r\n    /**\r\n     * Converts IP address to 32-bit integer\r\n     * @param {string} ip - IP address\r\n     * @returns {number} - 32-bit integer representation\r\n     */\r\n    function ipToInt(ip) {\r\n        return ip.split('.')\r\n            .reduce((int, octet) => (int << 8) + parseInt(octet, 10), 0) >>> 0;\r\n    }\r\n\r\n    /**\r\n     * Converts 32-bit integer to IP address\r\n     * @param {number} int - 32-bit integer\r\n     * @returns {string} - IP address\r\n     */\r\n    function intToIP(int) {\r\n        return [\r\n            (int >>> 24) & 255,\r\n            (int >>> 16) & 255,\r\n            (int >>> 8) & 255,\r\n            int & 255\r\n        ].join('.');\r\n    }\r\n\r\n    /**\r\n     * Converts number to 8-bit binary string\r\n     * @param {number} num - Number to convert\r\n     * @returns {string} - 8-bit binary string\r\n     */\r\n    function toBinary8(num) {\r\n        return num.toString(2).padStart(8, '0');\r\n    }\r\n\r\n    /**\r\n     * Converts IP address to binary string with dots\r\n     * @param {string} ip - IP address\r\n     * @returns {string} - Binary representation\r\n     */\r\n    function ipToBinary(ip) {\r\n        return ip.split('.')\r\n            .map(octet => toBinary8(parseInt(octet, 10)))\r\n            .join('.');\r\n    }\r\n\r\n    /**\r\n     * Generates subnet mask from prefix length\r\n     * @param {number} prefix - Prefix length (0-32)\r\n     * @returns {string} - Subnet mask in dotted decimal\r\n     */\r\n    function prefixToMask(prefix) {\r\n        const mask = (0xFFFFFFFF << (32 - prefix)) >>> 0;\r\n        return intToIP(mask);\r\n    }\r\n\r\n    /**\r\n     * Calculates network address\r\n     * @param {string} ip - IP address\r\n     * @param {number} prefix - Prefix length\r\n     * @returns {string} - Network address\r\n     */\r\n    function getNetworkAddress(ip, prefix) {\r\n        const ipInt = ipToInt(ip);\r\n        const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;\r\n        const networkInt = (ipInt & maskInt) >>> 0;\r\n        return intToIP(networkInt);\r\n    }\r\n\r\n    /**\r\n     * Calculates broadcast address\r\n     * @param {string} ip - IP address\r\n     * @param {number} prefix - Prefix length\r\n     * @returns {string} - Broadcast address\r\n     */\r\n    function getBroadcastAddress(ip, prefix) {\r\n        const networkInt = ipToInt(getNetworkAddress(ip, prefix));\r\n        const hostMask = (0xFFFFFFFF >>> prefix) >>> 0;\r\n        const broadcastInt = (networkInt | hostMask) >>> 0;\r\n        return intToIP(broadcastInt);\r\n    }\r\n\r\n    /**\r\n     * Calculates first usable host address\r\n     * @param {string} networkAddr - Network address\r\n     * @returns {string} - First usable host\r\n     */\r\n    function getFirstUsable(networkAddr) {\r\n        const networkInt = ipToInt(networkAddr);\r\n        return intToIP((networkInt + 1) >>> 0);\r\n    }\r\n\r\n    /**\r\n     * Calculates last usable host address\r\n     * @param {string} broadcastAddr - Broadcast address\r\n     * @returns {string} - Last usable host\r\n     */\r\n    function getLastUsable(broadcastAddr) {\r\n        const broadcastInt = ipToInt(broadcastAddr);\r\n        return intToIP((broadcastInt - 1) >>> 0);\r\n    }\r\n\r\n    /**\r\n     * Calculates number of usable hosts\r\n     * @param {number} prefix - Prefix length\r\n     * @returns {number} - Number of usable hosts\r\n     */\r\n    function getUsableHosts(prefix) {\r\n        if (prefix >= 31) return 0; // /31 and /32 have no usable hosts in standard subnetting\r\n        return Math.pow(2, 32 - prefix) - 2;\r\n    }\r\n\r\n    /**\r\n     * Calculates total number of addresses in subnet\r\n     * @param {number} prefix - Prefix length\r\n     * @returns {number} - Total addresses\r\n     */\r\n    function getTotalAddresses(prefix) {\r\n        return Math.pow(2, 32 - prefix);\r\n    }\r\n\r\n    /**\r\n     * Determines network class from IP\r\n     * @param {string} ip - IP address\r\n     * @returns {string} - Network class (A, B, C, D, E)\r\n     */\r\n    function getNetworkClass(ip) {\r\n        const firstOctet = parseInt(ip.split('.')[0], 10);\r\n        \r\n        if (firstOctet >= 1 && firstOctet <= 126) return 'A';\r\n        if (firstOctet >= 128 && firstOctet <= 191) return 'B';\r\n        if (firstOctet >= 192 && firstOctet <= 223) return 'C';\r\n        if (firstOctet >= 224 && firstOctet <= 239) return 'D (Multicast)';\r\n        if (firstOctet >= 240 && firstOctet <= 255) return 'E (Reserved)';\r\n        \r\n        return 'Unknown';\r\n    }\r\n\r\n    /**\r\n     * Determines if IP is private\r\n     * @param {string} ip - IP address\r\n     * @returns {boolean} - True if private\r\n     */\r\n    function isPrivateIP(ip) {\r\n        const ipInt = ipToInt(ip);\r\n        \r\n        // 10.0.0.0/8\r\n        if (ipInt >= ipToInt('10.0.0.0') && ipInt <= ipToInt('10.255.255.255')) return true;\r\n        \r\n        // 172.16.0.0/12\r\n        if (ipInt >= ipToInt('172.16.0.0') && ipInt <= ipToInt('172.31.255.255')) return true;\r\n        \r\n        // 192.168.0.0/16\r\n        if (ipInt >= ipToInt('192.168.0.0') && ipInt <= ipToInt('192.168.255.255')) return true;\r\n        \r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Calculates all subnets when splitting a network\r\n     * @param {string} baseIP - Base network IP\r\n     * @param {number} basePrefix - Base prefix length\r\n     * @param {number} newPrefix - New prefix length (for splitting)\r\n     * @returns {Array} - Array of subnet objects\r\n     */\r\n    function calculateSubnets(baseIP, basePrefix, newPrefix = null) {\r\n        if (!isValidIP(baseIP)) {\r\n            throw new Error('Invalid IP address');\r\n        }\r\n        \r\n        if (!isValidPrefix(basePrefix)) {\r\n            throw new Error('Invalid base prefix');\r\n        }\r\n        \r\n        // If no new prefix, return single network\r\n        if (newPrefix === null || newPrefix === basePrefix) {\r\n            const networkAddr = getNetworkAddress(baseIP, basePrefix);\r\n            const broadcastAddr = getBroadcastAddress(baseIP, basePrefix);\r\n            \r\n            return [{\r\n                subnetNumber: 1,\r\n                networkAddress: networkAddr,\r\n                broadcastAddress: broadcastAddr,\r\n                firstUsable: getFirstUsable(networkAddr),\r\n                lastUsable: getLastUsable(broadcastAddr),\r\n                usableHosts: getUsableHosts(basePrefix),\r\n                subnetMask: prefixToMask(basePrefix),\r\n                prefix: basePrefix,\r\n                totalAddresses: getTotalAddresses(basePrefix)\r\n            }];\r\n        }\r\n        \r\n        if (!isValidPrefix(newPrefix)) {\r\n            throw new Error('Invalid new prefix');\r\n        }\r\n        \r\n        if (newPrefix <= basePrefix) {\r\n            throw new Error('New prefix must be larger than base prefix');\r\n        }\r\n        \r\n        const baseNetworkAddr = getNetworkAddress(baseIP, basePrefix);\r\n        const baseNetworkInt = ipToInt(baseNetworkAddr);\r\n        const subnetSize = Math.pow(2, 32 - newPrefix);\r\n        const numSubnets = Math.pow(2, newPrefix - basePrefix);\r\n        \r\n        const subnets = [];\r\n        \r\n        for (let i = 0; i < numSubnets; i++) {\r\n            const subnetNetworkInt = (baseNetworkInt + (i * subnetSize)) >>> 0;\r\n            const networkAddr = intToIP(subnetNetworkInt);\r\n            const broadcastAddr = intToIP((subnetNetworkInt + subnetSize - 1) >>> 0);\r\n            \r\n            subnets.push({\r\n                subnetNumber: i + 1,\r\n                networkAddress: networkAddr,\r\n                broadcastAddress: broadcastAddr,\r\n                firstUsable: getFirstUsable(networkAddr),\r\n                lastUsable: getLastUsable(broadcastAddr),\r\n                usableHosts: getUsableHosts(newPrefix),\r\n                subnetMask: prefixToMask(newPrefix),\r\n                prefix: newPrefix,\r\n                totalAddresses: getTotalAddresses(newPrefix)\r\n            });\r\n        }\r\n        \r\n        return subnets;\r\n    }\r\n\r\n    /**\r\n     * Gets detailed information for binary visualization\r\n     * @param {string} ip - IP address\r\n     * @param {number} prefix - Prefix length\r\n     * @returns {Object} - Binary breakdown object\r\n     */\r\n    function getBinaryBreakdown(ip, prefix) {\r\n        const octets = ip.split('.').map(o => parseInt(o, 10));\r\n        const mask = prefixToMask(prefix);\r\n        const maskOctets = mask.split('.').map(o => parseInt(o, 10));\r\n        const networkAddr = getNetworkAddress(ip, prefix);\r\n        const networkOctets = networkAddr.split('.').map(o => parseInt(o, 10));\r\n        \r\n        const breakdown = {\r\n            ip: {\r\n                decimal: ip,\r\n                octets: octets,\r\n                binary: octets.map(o => toBinary8(o)),\r\n                fullBinary: ipToBinary(ip)\r\n            },\r\n            mask: {\r\n                decimal: mask,\r\n                octets: maskOctets,\r\n                binary: maskOctets.map(o => toBinary8(o)),\r\n                fullBinary: ipToBinary(mask),\r\n                prefix: prefix\r\n            },\r\n            network: {\r\n                decimal: networkAddr,\r\n                octets: networkOctets,\r\n                binary: networkOctets.map(o => toBinary8(o)),\r\n                fullBinary: ipToBinary(networkAddr)\r\n            },\r\n            networkBits: prefix,\r\n            hostBits: 32 - prefix\r\n        };\r\n        \r\n        return breakdown;\r\n    }\r\n\r\n    /**\r\n     * Generates subnet calculation summary\r\n     * @param {string} baseIP - Base IP address\r\n     * @param {number} basePrefix - Base prefix\r\n     * @param {number} newPrefix - New prefix (optional)\r\n     * @returns {Object} - Calculation summary\r\n     */\r\n    function getCalculationSummary(baseIP, basePrefix, newPrefix = null) {\r\n        const effectivePrefix = newPrefix || basePrefix;\r\n        const subnets = calculateSubnets(baseIP, basePrefix, newPrefix);\r\n        \r\n        return {\r\n            baseNetwork: getNetworkAddress(baseIP, basePrefix),\r\n            basePrefix: basePrefix,\r\n            newPrefix: newPrefix,\r\n            effectivePrefix: effectivePrefix,\r\n            subnetMask: prefixToMask(effectivePrefix),\r\n            totalSubnets: subnets.length,\r\n            hostsPerSubnet: getUsableHosts(effectivePrefix),\r\n            totalAddresses: getTotalAddresses(effectivePrefix),\r\n            networkClass: getNetworkClass(baseIP),\r\n            isPrivate: isPrivateIP(baseIP),\r\n            subnets: subnets\r\n        };\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        isValidIP,\r\n        isValidPrefix,\r\n        ipToInt,\r\n        intToIP,\r\n        toBinary8,\r\n        ipToBinary,\r\n        prefixToMask,\r\n        getNetworkAddress,\r\n        getBroadcastAddress,\r\n        getFirstUsable,\r\n        getLastUsable,\r\n        getUsableHosts,\r\n        getTotalAddresses,\r\n        getNetworkClass,\r\n        isPrivateIP,\r\n        calculateSubnets,\r\n        getBinaryBreakdown,\r\n        getCalculationSummary\r\n    };\r\n})();\r\n\r\n// Make available globally\r\nwindow.SubnetEngine = SubnetEngine;\r\n"]}