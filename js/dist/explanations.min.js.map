{"version":3,"sources":["explanations.js"],"names":["Explanations","generateExplanation","summary","basePrefix","newPrefix","effectivePrefix","subnetMask","totalSubnets","hostsPerSubnet","baseNetwork","networkClass","isPrivate","concat","content","steps","push","title","SubnetEngine","ipToBinary","icon","borrowedBits","Array","from","length","_","i","join","subnets","networkAddress","stepsHTML","broadcastAddress","firstUsable","lastUsable","generateQuickReference","renderSteps","map","step","generateBinaryExplanation","binary","ip","decimal","fullBinary","mask","networkBits","hostBits","network","generateFullExplanation","window"],"mappings":"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","file":"explanations.min.js","sourcesContent":["/**\r\n * ============================================\r\n * Explanations Module\r\n * ============================================\r\n * Generates human-friendly, educational explanations\r\n * for subnet calculations and concepts.\r\n * ============================================\r\n */\r\n\r\nconst Explanations = (function() {\r\n    'use strict';\r\n\r\n    /**\r\n     * Generates step-by-step explanation for subnet calculation\r\n     * @param {Object} summary - Calculation summary from SubnetEngine\r\n     * @returns {Array} - Array of explanation step objects\r\n     */\r\n    function generateExplanation(summary) {\r\n        const steps = [];\r\n        const { basePrefix, newPrefix, effectivePrefix, subnetMask, totalSubnets, hostsPerSubnet } = summary;\r\n\r\n        // Step 1: Understanding the Network\r\n        steps.push({\r\n            title: 'üåê Understanding the Network',\r\n            content: `\r\n                <p>You started with the network <code>${summary.baseNetwork}/${basePrefix}</code>.</p>\r\n                <p>This is a <strong>Class ${summary.networkClass}</strong> network, which is ${summary.isPrivate ? 'a <strong>private</strong> address range' : 'a <strong>public</strong> address'}.</p>\r\n                ${newPrefix ? `<p>You're splitting this network into smaller subnets using a /${newPrefix} prefix.</p>` : '<p>You\\'re analyzing this single network without subdivision.</p>'}\r\n            `,\r\n            icon: 'üåê'\r\n        });\r\n\r\n        // Step 2: Prefix Length and Subnet Mask\r\n        steps.push({\r\n            title: 'üî¢ Prefix Length and Subnet Mask',\r\n            content: `\r\n                <p>The prefix <code>/${effectivePrefix}</code> means the first <strong>${effectivePrefix} bits</strong> identify the network.</p>\r\n                <p>The remaining <strong>${32 - effectivePrefix} bits</strong> are available for host addresses.</p>\r\n                <div class=\"formula-box\">\r\n                    Subnet Mask: ${subnetMask}<br>\r\n                    In CIDR: /${effectivePrefix}\r\n                </div>\r\n                <p><strong>How it works:</strong> The subnet mask has ${effectivePrefix} consecutive 1-bits followed by ${32 - effectivePrefix} 0-bits.</p>\r\n                <p>In binary: <code>${SubnetEngine.ipToBinary(subnetMask)}</code></p>\r\n            `,\r\n            icon: 'üî¢'\r\n        });\r\n\r\n        // Step 3: Calculating Number of Subnets\r\n        if (newPrefix && newPrefix > basePrefix) {\r\n            const borrowedBits = newPrefix - basePrefix;\r\n            steps.push({\r\n                title: 'üìä Calculating Number of Subnets',\r\n                content: `\r\n                    <p><strong>Question:</strong> How many subnets can we create?</p>\r\n                    <p>To split the <code>/${basePrefix}</code> network into <code>/${newPrefix}</code> subnets, we borrow <strong>${borrowedBits} bit${borrowedBits > 1 ? 's' : ''}</strong> from the host portion.</p>\r\n                    \r\n                    <div class=\"formula-box\">\r\n                        <strong>Formula:</strong> Number of Subnets = 2<sup>borrowed bits</sup><br><br>\r\n                        Borrowed Bits = New Prefix - Base Prefix<br>\r\n                        Borrowed Bits = ${newPrefix} - ${basePrefix} = <strong>${borrowedBits} bit${borrowedBits > 1 ? 's' : ''}</strong><br><br>\r\n                        Number of Subnets = 2<sup>${borrowedBits}</sup> = <strong>${totalSubnets}</strong>\r\n                    </div>\r\n                    \r\n                    <p><strong>Step-by-Step Calculation:</strong></p>\r\n                    <ol>\r\n                        <li>Original prefix: /${basePrefix} (your base network)</li>\r\n                        <li>New prefix: /${newPrefix} (target subnet size)</li>\r\n                        <li>Subtract: ${newPrefix} - ${basePrefix} = ${borrowedBits} bits borrowed</li>\r\n                        <li>Calculate: 2<sup>${borrowedBits}</sup> = ${Array.from({length: borrowedBits}, (_, i) => 2).join(' √ó ')} = ${totalSubnets} subnets</li>\r\n                    </ol>\r\n                    \r\n                    <p><strong>Why does this work?</strong> Each additional bit we use for the network portion doubles the number of possible subnets. With ${borrowedBits} borrowed bit${borrowedBits > 1 ? 's' : ''}, we can create ${totalSubnets} unique subnet${totalSubnets > 1 ? 's' : ''}.</p>\r\n                    \r\n                    <div class=\"example-box\">\r\n                        <strong>üí° Real Example:</strong><br>\r\n                        If you have /${basePrefix} and split to /${newPrefix}:<br>\r\n                        ‚Ä¢ Borrowed ${borrowedBits} bit${borrowedBits > 1 ? 's' : ''}<br>\r\n                        ‚Ä¢ 2<sup>${borrowedBits}</sup> = ${totalSubnets} possible subnets<br>\r\n                        ‚Ä¢ Each subnet has /${newPrefix} prefix\r\n                    </div>\r\n                `,\r\n                icon: 'üìä'\r\n            });\r\n        } else {\r\n            steps.push({\r\n                title: 'üìä Single Network Analysis',\r\n                content: `\r\n                    <p>You're analyzing a single network without subdividing it.</p>\r\n                    <div class=\"formula-box\">\r\n                        Total Subnets = 1<br>\r\n                        (No subdivision performed)\r\n                    </div>\r\n                    <p><strong>Note:</strong> To create multiple subnets, enter a \"New Prefix\" value that is larger than your base prefix (/${basePrefix}).</p>\r\n                `,\r\n                icon: 'üìä'\r\n            });\r\n        }\r\n\r\n        // Step 4: Calculating Usable Hosts\r\n        steps.push({\r\n            title: 'üë• Calculating Usable Hosts',\r\n            content: `\r\n                <p>With <strong>${32 - effectivePrefix} host bits</strong>, we can calculate the number of usable host addresses.</p>\r\n                <div class=\"formula-box\">\r\n                    Usable Hosts = 2<sup>${32 - effectivePrefix}</sup> - 2 = ${hostsPerSubnet}\r\n                </div>\r\n                <p><strong>Why subtract 2?</strong> Every subnet has two special addresses:</p>\r\n                <ul>\r\n                    <li><strong>Network Address:</strong> The first address (all host bits = 0) identifies the subnet itself</li>\r\n                    <li><strong>Broadcast Address:</strong> The last address (all host bits = 1) is used for broadcasting to all hosts</li>\r\n                </ul>\r\n                <p>These two addresses cannot be assigned to individual hosts, so we subtract them from the total.</p>\r\n            `,\r\n            icon: 'üë•'\r\n        });\r\n\r\n        // Step 5: Network Address Calculation\r\n        steps.push({\r\n            title: 'üéØ Finding the Network Address',\r\n            content: `\r\n                <p>The <strong>Network Address</strong> is found by performing a bitwise AND operation between the IP address and subnet mask.</p>\r\n                <p><strong>Process:</strong></p>\r\n                <ol>\r\n                    <li>Convert both IP address and subnet mask to binary</li>\r\n                    <li>Perform AND operation (1 AND 1 = 1, otherwise 0)</li>\r\n                    <li>Convert result back to decimal</li>\r\n                </ol>\r\n                <p>This sets all host bits to 0, giving us the network's base address.</p>\r\n                <p><strong>Example:</strong> For ${summary.subnets[0].networkAddress}/${effectivePrefix}, the network address is <code>${summary.subnets[0].networkAddress}</code></p>\r\n            `,\r\n            icon: 'üéØ'\r\n        });\r\n\r\n        // Step 6: Broadcast Address Calculation\r\n        steps.push({\r\n            title: 'üì¢ Finding the Broadcast Address',\r\n            content: `\r\n                <p>The <strong>Broadcast Address</strong> is the last address in the subnet, used to send data to all hosts simultaneously.</p>\r\n                <p><strong>Process:</strong></p>\r\n                <ol>\r\n                    <li>Start with the network address</li>\r\n                    <li>Set all host bits to 1</li>\r\n                    <li>This gives the highest address in the subnet</li>\r\n                </ol>\r\n                <p><strong>Example:</strong> For the subnet ${summary.subnets[0].networkAddress}/${effectivePrefix}, the broadcast address is <code>${summary.subnets[0].broadcastAddress}</code></p>\r\n            `,\r\n            icon: 'üì¢'\r\n        });\r\n\r\n        // Step 7: Usable Host Range\r\n        steps.push({\r\n            title: 'üîÑ Determining Usable Host Range',\r\n            content: `\r\n                <p>The <strong>Usable Host Range</strong> includes all addresses between the network and broadcast addresses.</p>\r\n                <p><strong>Calculation:</strong></p>\r\n                <ul>\r\n                    <li><strong>First Usable:</strong> Network Address + 1</li>\r\n                    <li><strong>Last Usable:</strong> Broadcast Address - 1</li>\r\n                </ul>\r\n                <p><strong>Example for first subnet:</strong></p>\r\n                <div class=\"formula-box\">\r\n                    First Usable: ${summary.subnets[0].firstUsable}<br>\r\n                    Last Usable: ${summary.subnets[0].lastUsable}\r\n                </div>\r\n                <p>These are the addresses you can assign to devices like computers, printers, and servers.</p>\r\n            `,\r\n            icon: 'üîÑ'\r\n        });\r\n\r\n        // Step 8: Practical Application\r\n        steps.push({\r\n            title: 'üõ†Ô∏è Practical Application',\r\n            content: `\r\n                <p><strong>Summary of your subnet configuration:</strong></p>\r\n                <ul>\r\n                    <li>You have <strong>${totalSubnets}</strong> subnet${totalSubnets > 1 ? 's' : ''} available</li>\r\n                    <li>Each subnet can support <strong>${hostsPerSubnet}</strong> usable host${hostsPerSubnet !== 1 ? 's' : ''}</li>\r\n                    <li>Total capacity: <strong>${totalSubnets * hostsPerSubnet}</strong> devices across all subnets</li>\r\n                </ul>\r\n                <p><strong>Best Practices:</strong></p>\r\n                <ul>\r\n                    <li>Assign the first usable address to your gateway/router</li>\r\n                    <li>Document which devices use which addresses</li>\r\n                    <li>Reserve ranges for static and DHCP allocations</li>\r\n                    <li>Plan for future growth when choosing subnet sizes</li>\r\n                </ul>\r\n            `,\r\n            icon: 'üõ†Ô∏è'\r\n        });\r\n\r\n        return steps;\r\n    }\r\n\r\n    /**\r\n     * Generates explanation for binary conversion\r\n     * @param {Object} binary - Binary breakdown from SubnetEngine\r\n     * @returns {string} - HTML explanation\r\n     */\r\n    function generateBinaryExplanation(binary) {\r\n        return `\r\n            <div class=\"explanation-step\">\r\n                <h3>üî¢ Understanding Binary Notation</h3>\r\n                <p>Every IP address is actually a 32-bit number. We usually write it in decimal for convenience, but computers work with binary (1s and 0s).</p>\r\n                \r\n                <p><strong>Your IP Address:</strong></p>\r\n                <ul>\r\n                    <li>Decimal: <code>${binary.ip.decimal}</code></li>\r\n                    <li>Binary: <code>${binary.ip.fullBinary}</code></li>\r\n                </ul>\r\n\r\n                <p><strong>The Subnet Mask:</strong></p>\r\n                <ul>\r\n                    <li>Decimal: <code>${binary.mask.decimal}</code></li>\r\n                    <li>Binary: <code>${binary.mask.fullBinary}</code></li>\r\n                </ul>\r\n\r\n                <p>The mask has <strong>${binary.networkBits} network bits</strong> (shown in blue) and <strong>${binary.hostBits} host bits</strong> (shown in orange).</p>\r\n                \r\n                <p><strong>Network Address:</strong> Created by setting all host bits to 0:</p>\r\n                <ul>\r\n                    <li>Decimal: <code>${binary.network.decimal}</code></li>\r\n                    <li>Binary: <code>${binary.network.fullBinary}</code></li>\r\n                </ul>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Generates quick reference guide\r\n     * @returns {string} - HTML quick reference\r\n     */\r\n    function generateQuickReference() {\r\n        return `\r\n            <div class=\"explanation-step\">\r\n                <h3>üìö Quick Reference Guide</h3>\r\n                \r\n                <p><strong>Common Subnet Masks:</strong></p>\r\n                <div class=\"formula-box\">\r\n                    /24 = 255.255.255.0 ‚Üí 254 hosts<br>\r\n                    /25 = 255.255.255.128 ‚Üí 126 hosts<br>\r\n                    /26 = 255.255.255.192 ‚Üí 62 hosts<br>\r\n                    /27 = 255.255.255.224 ‚Üí 30 hosts<br>\r\n                    /28 = 255.255.255.240 ‚Üí 14 hosts<br>\r\n                    /29 = 255.255.255.248 ‚Üí 6 hosts<br>\r\n                    /30 = 255.255.255.252 ‚Üí 2 hosts\r\n                </div>\r\n\r\n                <p><strong>Private IP Ranges:</strong></p>\r\n                <ul>\r\n                    <li>Class A: <code>10.0.0.0/8</code> (10.0.0.0 - 10.255.255.255)</li>\r\n                    <li>Class B: <code>172.16.0.0/12</code> (172.16.0.0 - 172.31.255.255)</li>\r\n                    <li>Class C: <code>192.168.0.0/16</code> (192.168.0.0 - 192.168.255.255)</li>\r\n                </ul>\r\n\r\n                <p><strong>Key Formulas:</strong></p>\r\n                <ul>\r\n                    <li>Number of Subnets = 2<sup>borrowed bits</sup></li>\r\n                    <li>Hosts per Subnet = 2<sup>host bits</sup> - 2</li>\r\n                    <li>Network Address = IP AND Subnet Mask</li>\r\n                    <li>Broadcast Address = Network OR (NOT Subnet Mask)</li>\r\n                </ul>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    /**\r\n     * Renders explanation steps to HTML\r\n     * @param {Array} steps - Array of explanation steps\r\n     * @returns {string} - HTML string\r\n     */\r\n    function renderSteps(steps) {\r\n        return steps.map(step => `\r\n            <div class=\"explanation-step\">\r\n                <h3>${step.icon} ${step.title}</h3>\r\n                ${step.content}\r\n            </div>\r\n        `).join('');\r\n    }\r\n\r\n    /**\r\n     * Main function to generate and render all explanations\r\n     * @param {Object} summary - Calculation summary\r\n     * @param {Object} binary - Binary breakdown\r\n     * @returns {string} - Complete HTML explanation\r\n     */\r\n    function generateFullExplanation(summary, binary) {\r\n        const steps = generateExplanation(summary);\r\n        const stepsHTML = renderSteps(steps);\r\n        const quickRef = generateQuickReference();\r\n        \r\n        return stepsHTML + quickRef;\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        generateExplanation,\r\n        generateBinaryExplanation,\r\n        generateQuickReference,\r\n        renderSteps,\r\n        generateFullExplanation\r\n    };\r\n})();\r\n\r\n// Make available globally\r\nwindow.Explanations = Explanations;\r\n"]}